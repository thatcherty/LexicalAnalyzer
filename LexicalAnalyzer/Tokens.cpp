#include "Tokens.h"

Tokens::Tokens()
{
	token_list["int"] = "KEYWORD";
	token_list["("] = "LPAREN";
	token_list[")"] = "RPAREN";
	token_list["{"] = "LBRACE";
	token_list["}"] = "RBRACE";
	token_list["="] = "EQUALS";
	token_list[","] = "COMMA";
	token_list[";"] = "SEMICOLON";
	token_list["for"] = "KEYWORD";
	token_list[">"] = "GREAT_SIGN";
	token_list["+="] = "PLUS_EQUALS";
	token_list["/*"] = "START COMMENT";
	token_list["*/"] = "END COMMENT";
	token_list["return"] = "KEYWORD";
	token_list["\n"] = "NEW LINE";
	token_list[" "] = "SPACE";
	token_list["\t"] = "TAB";
}

void Tokens::tokenize(string& code)
{
	int line = 1;
	int token_num = 1;
	stack<string> t_stack{};
	string val_so_far = "";

	for (int i = 0; i < code.length(); i++)
	{
		string temp = code.substr(i,1);
		val_so_far += temp;

		
		if (token_list.find(val_so_far) != token_list.end())
		{
			
			// find null characters
			if (token_list[val_so_far] == "NEW LINE")
			{
				++line;
				val_so_far = "";
			}
			else if (token_list[val_so_far] == "SPACE" || token_list[val_so_far] == "TAB")
			{
				val_so_far = "";
			}
			else if (token_list[val_so_far] == "START COMMENT")
			{
				while (token_list[val_so_far] != "END COMMENT")
				{
					++i;
				}
			}
			else
			{
				cout << token_num << ". " << val_so_far << " " << token_list[val_so_far] << " " << line << endl;
				++token_num;
				val_so_far = "";
			}

		}

		// consider the keywords and identifiers
		// if something is not found in the token list, it could be an identifier
		// a keyword must be surrounded by whitespace
		// consider adjusting whitespace identification to check the word so far and print as identifier or keyword
		// additionally, += should print together and an equal sign should not be generated by itself
		// consider breaking into multiple scanning functions
		
	}


}
